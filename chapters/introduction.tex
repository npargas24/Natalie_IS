%!TEX root = ../main.tex\
\chapter{Introduction}\label{intro}
\section{What is Reverse Engineering?}

Reverse engineering is the process of disassembling, deconstructing, or analyzing a system, device, or piece of software in order to gain a deep understanding of how it functions. This concept has existed long before its modern applications in technology. For example, the dissections many of us performed in high school biology classes were, in essence, an early form of reverse engineering. Those dissections were carried out to break down something as complex and mystifying as life into understandable components and functions, revealing how various biological systems worked together. Similarly, one of the most effective ways to fully comprehend how a technological system operates is to open it up and inspect it piece by piece.

Reverse engineering software can be accomplished through a variety of techniques. Broadly speaking, these methods fall into two categories: static analysis and dynamic analysis. Static analysis involves studying a snapshot of the code in a single, unchanging state without executing it. This provides insight into how the software is structured, its logic, and potential areas of interest. In contrast, dynamic analysis takes place while the program is actively running, allowing an analyst to observe how it behaves in real time, including how it handles data and responds to inputs. Typically, a reverse engineering process might begin by passing a program’s executable to a disassembler, which translates machine code into assembly-level instructions. From there, a programmer might use system monitoring tools to gather information provided by the operating system about how the program interacts with its environment. Additionally, debuggers allow reversers to observe the CPU’s internal operations, stepping through the disassembled code one instruction at a time to scrutinize the logic behind each operation. Using these various tools, a programmer must rely heavily on intuition, experience, and problem-solving skills to navigate the complex and often opaque process of reverse engineering.

There are numerous reasons someone might choose to reverse engineer software. The only time the inner workings of software are openly accessible to anyone is when it is released as open source. Open source software consists of freely available source code that anyone can read, modify, or distribute. However, developers frequently choose not to make their source code public for a range of reasons, including legal and licensing restrictions, protection of proprietary technologies, or personal business strategies. The opacity of proprietary software often leaves users, researchers, or competing developers with no choice but to reverse engineer if they wish to understand or interact with it.

Some of the most common motivations for reverse engineering software include performing malware analysis, improving one’s programming skills, recovering lost source code, and enabling interoperability between different systems or applications. My own first introduction to the world of reverse engineering came through a video in which the creator was reverse engineering Apple’s FaceTime for Mac. His goal was to reinstate closed captioning functionality for his hearing-impaired mother—a striking example of how reverse engineering can serve highly personal and practical purposes. The potential applications of reverse engineering are as diverse and far-reaching as the software programs that exist today.

Most software developers are familiar with reverse engineering primarily through its use in malware analysis. A classic example of malware is a Trojan virus, in which malicious developers conceal harmful code inside programs that appear harmless. Reverse engineering such programs allows security researchers to break them apart and reveal the hidden malware lurking within. Additionally, modern software development often involves the use of external libraries. In large projects, keeping track of all dependencies and the interactions between different modules can be a formidable challenge. Hackers can exploit this complexity by hiding malicious entry points in these libraries to gain unauthorized access to sensitive information. In many cases, reverse engineering remains the only foolproof method for uncovering the true operations of a program and exposing any hidden threats or vulnerabilities embedded deep within the code.

Another compelling reason to reverse engineer software is to enhance one’s own technical skills. The process requires extensive knowledge of both low-level assembly language and high-level programming concepts. Reverse engineering someone else’s code is no simple feat. It forces the reverser to learn deeply about various methods of structuring and implementing software, as well as the diverse strategies developers use to solve problems. Through this process, reverse engineers often become far more proficient programmers, gaining insight into advanced coding techniques and architectural design choices that might not be visible in standard learning materials. This project itself will serve as an endeavor in learning not only forward engineering but also the intricate art and science of reverse engineering.

Another reason people may reverse engineer software is to recover lost source code. Though this is far from easy, it is sometimes possible to reconstruct high-level source code from compiled executables. Many developers have experienced the frustration and panic that comes with losing source code due to accidental deletion, hardware failures, or lack of proper backups. In such scenarios, reverse engineering can offer a potential solution, providing a lifeline to recover critical work that might otherwise be lost forever.

Interoperability represents yet another crucial motivation for reverse engineering. In many cases, achieving compatibility between different programs, systems, or devices is impossible without reverse engineering. When working with external libraries or operating systems that provide documentation without accompanying source code, developers frequently encounter undocumented behaviors or missing details. While a programmer could attempt to resolve these issues through trial and error or by contacting the vendor, reverse engineering provides a definitive and often faster way to understand how to integrate different systems effectively. It serves as a bridge between incompatible software components, enabling seamless communication and cooperation in ways that might otherwise remain impossible.

This project serves as a case study in using reverse engineering to achieve interoperability with a proprietary Bluetooth device.
